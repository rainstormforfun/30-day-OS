
# 鼠标控制与32位模式切换

## 鼠标解读(1)

现在我们已经能从鼠标取得数据了。紧接的问题是要怎么解读这些数据，让鼠标指针相应的动起来。

```c title="bootpack.c"
unsigned char mouse_dbuf[3], mouse_phase;

enable_mouse();
	mouse_phase = 0; //进入到等待鼠标的0xfa状态

	for (;;) {
		io_cli();
		if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) == 0) {
			io_stihlt();
		} else {
			if (fifo8_status(&keyfifo) != 0) {
				i = fifo8_get(&keyfifo);
				io_sti();
				sprintf(s, "%02X", i);
				boxfill8(binfo->vram, binfo->scrnx, COL8_008484,  0, 16, 15, 31);
				putfonts8_asc(binfo->vram, binfo->scrnx, 0, 16, COL8_FFFFFF, s);
			} else if (fifo8_status(&mousefifo) != 0) {
				i = fifo8_get(&mousefifo);
				io_sti();
				if (mouse_phase == 0) {
				//等待鼠标的0xfa状态
					if (i == 0xfa) {
						mouse_phase = 1;
					}
				} else if (mouse_phase == 1) {
					//等待鼠标的第一字节
					mouse_dbuf[0] = i;
					mouse_phase = 2;
				} else if (mouse_phase == 2) {
					//等待鼠标的第二字节
					mouse_dbuf[1] = i;
					mouse_phase = 3;
				} else if (mouse_phase == 3) {
					//等待鼠标的第三字节 
					mouse_dbuf[2] = i;
					mouse_phase = 1;
					//鼠标的3个字节都齐了，显示出来
					sprintf(s, "%02X %02X %02X", mouse_dbuf[0], mouse_dbuf[1], mouse_dbuf[2]);
					boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 32, 16, 32 + 8 * 8 - 1, 31);
					putfonts8_asc(binfo->vram, binfo->scrnx, 32, 16, COL8_FFFFFF, s);
				}
			}
		}
	}
```

这段程序，首先要把最初读到的`0xfa`舍弃掉。之后，每次从鼠标那里送过来的数据都应该是3个字节一组，显示到屏幕上。

![image.png](https://vs-picbed-1320307070.cos.ap-nanjing.myqcloud.com/img/20240303095349.png)

`mouse_dbuf[0]`与鼠标点击有关，`mouse_dbuf[1]`与鼠标左右移动有关，`mouse_dbuf[2]`与鼠标上下移动有关。

## 稍事整理

```c title="bootpack.c"
struct MOUSE_DEC {
	unsigned char buf[3], phase;
};

int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat)
{
	if (mdec->phase == 0) {
		/* マウスの0xfaを待っている段階 */
		if (dat == 0xfa) {
			mdec->phase = 1;
		}
		return 0;
	}
	if (mdec->phase == 1) {
		/* マウスの1バイト目を待っている段階 */
		mdec->buf[0] = dat;
		mdec->phase = 2;
		return 0;
	}
	if (mdec->phase == 2) {
		/* マウスの2バイト目を待っている段階 */
		mdec->buf[1] = dat;
		mdec->phase = 3;
		return 0;
	}
	if (mdec->phase == 3) {
		/* マウスの3バイト目を待っている段階 */
		mdec->buf[2] = dat;
		mdec->phase = 1;
		return 1;
	}
	return -1; /* ここに来ることはないはず */
}

enable_mouse(&mdec);

for (;;) {
	io_cli();
	if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) == 0) {
		io_stihlt();
	} else {
		if (fifo8_status(&keyfifo) != 0) {
			i = fifo8_get(&keyfifo);
			io_sti();
			sprintf(s, "%02X", i);
			boxfill8(binfo->vram, binfo->scrnx, COL8_008484,  0, 16, 15, 31);
			putfonts8_asc(binfo->vram, binfo->scrnx, 0, 16, COL8_FFFFFF, s);
		} else if (fifo8_status(&mousefifo) != 0) {
			i = fifo8_get(&mousefifo);
			io_sti();
			if (mouse_decode(&mdec, i) != 0) {
				/* データが3バイト揃ったので表示 */
				sprintf(s, "%02X %02X %02X", mdec.buf[0], mdec.buf[1], mdec.buf[2]);
				boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 32, 16, 32 + 8 * 8 - 1, 31);
				putfonts8_asc(binfo->vram, binfo->scrnx, 32, 16, COL8_FFFFFF, s);
			}
		}
	}
}
```

## 鼠标解读(2)

```c title="bootpack.cc"
struct MOUSE_DEC {
	unsigned char buf[3], phase;
	int x, y, btn;
};

int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat)
{
	if (mdec->phase == 0) {
		//等待鼠标的0xfa的阶段
		if (dat == 0xfa) {
			mdec->phase = 1;
		}
		return 0;
	}
	if (mdec->phase == 1) {
		//等待鼠标第一字节的阶段
		if ((dat & 0xc8) == 0x08) {
			//如果第一字节正确
			mdec->buf[0] = dat;
			mdec->phase = 2;
		}
		return 0;
	}
	if (mdec->phase == 2) {
		//等待鼠标第二字节的阶段
		mdec->buf[1] = dat;
		mdec->phase = 3;
		return 0;
	}
	if (mdec->phase == 3) {
		//等待鼠标第三字节的阶段
		mdec->buf[2] = dat;
		mdec->phase = 1;
		mdec->btn = mdec->buf[0] & 0x07;
		mdec->x = mdec->buf[1];
		mdec->y = mdec->buf[2];
		if ((mdec->buf[0] & 0x10) != 0) {
			mdec->x |= 0xffffff00;
		}
		if ((mdec->buf[0] & 0x20) != 0) {
			mdec->y |= 0xffffff00;
		}
		mdec->y = - mdec->y; //鼠标的y方向与画面符号相反 
		return 1;
	}
	return -1; /* ここに来ることはないはず */
}
```

结构体里增加的几个变量用于存放解读结果，这几个变量是`x`、`y`和`btn`，分别用于存放移动信息和鼠标按键状态。

同时，还要检查`if (mdec->phase == 1)`中第一字节对移动有反应的部分是否在`0~3`范围内，对点击有反应的部分是否在`8~F`范围内`if (mdec->phase == 1)`。

鼠标键的状态，放在`buf[0]`的低3位，`mdec->btn = mdec->buf[0] & 0x07;`。

x和y，基本上是直接使用`buf[1]`和`buf[2]`，但是需要使用第一字节中对鼠标移动有反应的几位信息。还有，要将x和y的第8位及第8位以后全部都设成1或0。

还有鼠标与屏幕的y方向正好相反。

下面是显示部分：

```c title="bootpack.c"
} else if (fifo8_status(&mousefifo) != 0) {
	i = fifo8_get(&mousefifo);
	io_sti();
	if (mouse_decode(&mdec, i) != 0) {
		//数据的3个字节都齐了，显示出来
		sprintf(s, "[lcr %4d %4d]", mdec.x, mdec.y);
		if ((mdec.btn & 0x01) != 0) {
			s[1] = 'L';
		}
		if ((mdec.btn & 0x02) != 0) {
			s[3] = 'R';
		}
		if ((mdec.btn & 0x04) != 0) {
			s[2] = 'C';
		}
		boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 32, 16, 32 + 15 * 8 - 1, 31);
		putfonts8_asc(binfo->vram, binfo->scrnx, 32, 16, COL8_FFFFFF, s);
	}
}
```

![image.png](https://vs-picbed-1320307070.cos.ap-nanjing.myqcloud.com/img/20240303103352.png)

## 移动鼠标指针

```c title="bootpack.c"
} else if (fifo8_status(&mousefifo) != 0) {
	i = fifo8_get(&mousefifo);
	io_sti();
	if (mouse_decode(&mdec, i) != 0) {
		/* データが3バイト揃ったので表示 */
		sprintf(s, "[lcr %4d %4d]", mdec.x, mdec.y);
		if ((mdec.btn & 0x01) != 0) {
			s[1] = 'L';
		}
		if ((mdec.btn & 0x02) != 0) {
			s[3] = 'R';
		}
		if ((mdec.btn & 0x04) != 0) {
			s[2] = 'C';
		}
		boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 32, 16, 32 + 15 * 8 - 1, 31);
		putfonts8_asc(binfo->vram, binfo->scrnx, 32, 16, COL8_FFFFFF, s);
		//鼠标指针的移动
		boxfill8(binfo->vram, binfo->scrnx, COL8_008484, mx, my, mx + 15, my + 15); //隐藏鼠标
		mx += mdec.x;
		my += mdec.y;
		if (mx < 0) {
			mx = 0;
		}
		if (my < 0) {
			my = 0;
		}
		if (mx > binfo->scrnx - 16) {
			mx = binfo->scrnx - 16;
		}
		if (my > binfo->scrny - 16) {
			my = binfo->scrny - 16;
		}
		sprintf(s, "(%3d, %3d)", mx, my);
		boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 0, 0, 79, 15); //隐藏坐标
		putfonts8_asc(binfo->vram, binfo->scrnx, 0, 0, COL8_FFFFFF, s); //显示坐标
		putblock8_8(binfo->vram, binfo->scrnx, 16, 16, mx, my, mcursor, 16); //描画鼠标
	}
}
}
}
```

![image.png](https://vs-picbed-1320307070.cos.ap-nanjing.myqcloud.com/img/20240303104035.png)
