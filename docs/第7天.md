
# 第7天 FIFO与鼠标控制

## 获取案件编码

我们将程序改善一下，让程序在按下一个键后不结束，而是把所按键的编码在画面上显示出来。

```c title="int.c"
#define PORT_KEYDAT		0x0060

void inthandler21(int *esp)
{
	struct BOOTINFO *binfo = (struct BOOTINFO *) ADR_BOOTINFO;
	unsigned char data, s[4];
	io_out8(PIC0_OCW2, 0x61);	/* IRQ-01受付完了をPICに通知 */
	data = io_in8(PORT_KEYDAT);

	sprintf(s, "%02X", data);
	boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 0, 16, 15, 31);
	putfonts8_asc(binfo->vram, binfo->scrnx, 0, 16, COL8_FFFFFF, s);

	return;
}
```

`io_out8(PIC0_OCW2, 0x61);`用来通知PIC：已经知道生了**IRQ1**中断了。如果是IRQ3，则写成`0x63`，输出给`OCW2`就可以。

执行这句话之后，PIC继续监视IRQ1中断是否发生。

![image.png](https://vs-picbed-1320307070.cos.ap-nanjing.myqcloud.com/img/20240302161332.png)

键按下去和松开会分别出现一个十六进制数字。

##  加快中断处理

问题是，字符显示的内容被放在了中断处理程序中。所谓中断处理，本来就是打断CPU本来的工作，所以必须完成的干净利索。而且中断处理期间，不再接收别的中断。所以如果处理键盘的中断速度太慢，就会出现鼠标的运动不连贯、不能从网上接收数据等情况。

另一方面，字符显示要花大块时间来进行处理。仅仅画一个字符，就要执行`8*16=128`次if语句。

那该如何是好呢？结论就是，先将按键的编码接收下来，保存到变量里，然后由`HariMain`偶尔去查看这个变量。如果发现有了数据，就把它显示出来。

```c
struct KEYBUF {
	unsigned char data, flag;
};
struct KEYBUF keybuf;

void inthandler21(int *esp)
{
	unsigned char data;
	io_out8(PIC0_OCW2, 0x61);	/* IRQ-01受付完了をPICに通知 */
	data = io_in8(PORT_KEYDAT);
	if (keybuf.flag == 0) {
		keybuf.data = data;
		keybuf.flag = 1;
	}
	return;
}
```

对`HariMain`最后的无限循环进行修改：

```c
	for (;;) {
		io_cli();
		if (keybuf.flag == 0) {
			io_stihlt();
		} else {
			i = keybuf.data;
			keybuf.flag = 0;
			io_sti();
			sprintf(s, "%02X", i);
			boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 0, 16, 15, 31);
			putfonts8_asc(binfo->vram, binfo->scrnx, 0, 16, COL8_FFFFFF, s);
		}
	}
```

根据CPU的规范，机器语言的`STI`指令之后，如果紧跟着`HLT`指令，那么就暂不受理这两条指令之间的中断，而要等到`HLT`指令之后才受理，所以使用`io_stihlt`函数就能克服这一问题。

![image.png](https://vs-picbed-1320307070.cos.ap-nanjing.myqcloud.com/img/20240302190853.png)

但是键盘的右`ctrl`按下还是松开，屏幕上显示的都是`E0`，原因是按下时，产生键码值`E0 1D`，而松开后产生`E0 9D`，所以一次按键产生两次中断，第一次中断发送`E0`，第二次中断时发送`1D`。但是`1D`被舍弃了，因为要显示`E0`。

## 制作FIFO缓冲区

问题出在缓冲区，它只能存储一个字节：

```c
struct KEYBUF {
	unsigned char data, flag;
};
```

可以改为：

```c
struct KEYBUF
{
	unsigned char data[4];
}
```

现在我们需要一个FIFO型缓冲区，希望输入ABC，输出ABC。

```c title="int.c"
struct KEYBUF {
	unsigned char data[32];
	int next;
};
void inthandler21(int *esp)
{
	unsigned char data;
	io_out8(PIC0_OCW2, 0x61);	//通知PIC IRQ-01已经受理完毕
	data = io_in8(PORT_KEYDAT);
	if (keybuf.next < 32) {
		keybuf.data[keybuf.next] = data;
		keybuf.next++;
	}
	return;
}
```

```c title="bootpack.c"
	for (;;) {
		io_cli();
		if (keybuf.next == 0) {
			io_stihlt();
		} else {
			i = keybuf.data[0];
			keybuf.next--;
			for (j = 0; j < keybuf.next; j++) {
				keybuf.data[j] = keybuf.data[j + 1];
			}
			io_sti();
			sprintf(s, "%02X", i);
			boxfill8(binfo->vram, binfo->scrnx, COL8_008484, 0, 16, 15, 31);
			putfonts8_asc(binfo->vram, binfo->scrnx, 0, 16, COL8_FFFFFF, s);
		}
	}
```

现在`inthandler21`没有问题了，但是`HariMain`中，禁止中断期间需要移送大量数据。